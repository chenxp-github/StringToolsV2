function code_cpp(names)
	printfnl("#include \"%s.h\"",to_file_name(names.class_name));
	
	common_include_c();
	
	printfnl("");
	printfnl("status_t %s_init(%s *self)",names.entry_class_name,names.c_entry_class_name);
	printfnl("{");
	printfnl("    self->next = NULL;");
	printfnl("    self->raw_ptr = NULL;");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("");
	printfnl("status_t %s_destroy(%s *self)",names.entry_class_name,names.c_entry_class_name);
	printfnl("{");
	printfnl("    %s_destroy(self->raw_ptr);",names.node_class_name_lower);
	printfnl("    X_FREE(self->raw_ptr);");
	printfnl("    self->next = NULL;");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("");
	printfnl("status_t %s_set(%s *self, %s *node)",names.entry_class_name,names.c_entry_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    ASSERT(self->raw_ptr == NULL);");
	printfnl("    self->raw_ptr = node;");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("");
	printfnl("%s* %s_get(%s *self)",names.c_node_class_name,names.entry_class_name,names.c_entry_class_name);
	printfnl("{");
	printfnl("    return self->raw_ptr;");
	printfnl("}");
	printfnl("");
	printfnl("/********************************************************************/");
	printfnl("bool_t %s_equals(%s *self,%s *node1, %s *node2);",names.class_name_lower,names.c_class_name,names.c_node_class_name,names.c_node_class_name);
	printfnl("%s* %s_clone_node(%s *self,%s *node);",names.c_node_class_name,names.class_name_lower,names.c_class_name,names.c_node_class_name);	
	printfnl("");
	printfnl("status_t %s_init_basic(%s *self)",names.class_name_lower,names.c_class_name);
	printfnl("{");
	printfnl("    self->capacity = 0;");
	printfnl("    self->data = 0;");
	printfnl("    self->size = 0;");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("status_t %s_init(%s *self,int capacity)",names.class_name_lower,names.c_class_name);
	printfnl("{");
	printfnl("    %s_init_basic(self);",names.class_name_lower);
	printfnl("    self->capacity = capacity;");
	printfnl("    X_MALLOC(self->data,%s*,capacity);",names.c_entry_class_name);
	printfnl("    memset(self->data,0,capacity*sizeof(%s*));",names.c_entry_class_name);
	printfnl("    return OK;");
	printfnl("}");
	printfnl("status_t %s_destroy(%s *self)",names.class_name_lower,names.c_class_name);
	printfnl("{");
	printfnl("    int i;");
	printfnl("    %s *q,*p;",names.c_entry_class_name);
	printfnl("    ");
	printfnl("    if(self == NULL)return ERROR;");
	printfnl("");
	printfnl("    if(self->data == NULL)");
	printfnl("        return OK;");
	printfnl("");
	printfnl("    for(i = 0; i < self->capacity; i++)");
	printfnl("    {");
	printfnl("        p  = self->data[i];");
	printfnl("        while(p)");
	printfnl("        {");
	printfnl("            q = p->next;");
	printfnl("            %s_del_entry(self,p);",names.class_name_lower);
	printfnl("            p = q;            ");
	printfnl("        }            ");
	printfnl("    }");
	printfnl("    X_FREE(self->data);");
	printfnl("    %s_init_basic(self);",names.class_name_lower);
	printfnl("    return OK;");
	printfnl("}");
	printfnl("");
	printfnl("status_t %s_put_ptr(%s *self,%s *ptr)",names.class_name_lower,names.c_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    int code;");
	printfnl("    %s *p,*ptr_entry;",names.c_entry_class_name);
	printfnl("");
	printfnl("    ASSERT(ptr);");
	printfnl("");
	printfnl("    if(%s_get(self,ptr) != NULL)",names.class_name_lower);
	printfnl("        return ERROR;");
	printfnl("");
	printfnl("    code = %s_hash_code(self,ptr);",names.class_name_lower);
	printfnl("    ASSERT(code >= 0 && code < self->capacity);");
	printfnl("    p = self->data[code];");
	printfnl("");
	printfnl("    X_MALLOC(ptr_entry,%s,1);",names.c_entry_class_name);
	printfnl("    %s_init(ptr_entry);",names.entry_class_name);
	printfnl("    %s_set(ptr_entry,ptr);",names.entry_class_name);
	printfnl("");
	printfnl("    if (p == NULL)");
	printfnl("    {");
	printfnl("        self->data[code] = ptr_entry;");
	printfnl("        ptr_entry->next = NULL;");
	printfnl("    }");
	printfnl("    else");
	printfnl("    {");
	printfnl("        while(p->next)");
	printfnl("        {");
	printfnl("            p = p->next;");
	printfnl("        }");
	printfnl("        p->next = ptr_entry;");
	printfnl("        ptr_entry->next = NULL;");
	printfnl("    }");
	printfnl("    self->size++;");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("");
	printfnl("status_t %s_put(%s *self,%s *hashentry)",names.class_name_lower,names.c_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    %s *tmp = %s_clone_node(self,hashentry);",names.c_node_class_name,names.class_name_lower);
	printfnl("    if(!%s_put_ptr(self,tmp))",names.class_name_lower);
	printfnl("    {");	
	printfnl("        %s_destroy(tmp);",names.node_class_name_lower);
	printfnl("        X_FREE(tmp);");
	printfnl("        return ERROR;");
	printfnl("    }");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("");
	printfnl("%s* %s_get(%s *self,%s *key)",names.c_node_class_name,names.class_name_lower,names.c_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    int code;");
	printfnl("    %s *p;",names.c_entry_class_name);
	printfnl("");
	printfnl("    ASSERT(key);");
	printfnl("");
	printfnl("    code = %s_hash_code(self,key);",names.class_name_lower);
	printfnl("    ASSERT(code >= 0 && code < self->capacity);");
	printfnl("    p = self->data[code];");
	printfnl("    while(p)");
	printfnl("    {");
	printfnl("        %s *node = %s_get(p);",names.c_node_class_name,names.entry_class_name);
	printfnl("        if(%s_equals(self,node,key))",names.class_name_lower);
	printfnl("        {            ");
	printfnl("            return node;");
	printfnl("        }");
	printfnl("        p = p->next;");
	printfnl("    }");
	printfnl("    return NULL;");
	printfnl("}");
	printfnl("");
	printfnl("status_t %s_enum_all(%s *self,struct closure *callback)",names.class_name_lower,names.c_class_name);
	printfnl("{");
	printfnl("    int i,_contine;");
	printfnl("    %s *pre,*p,*next;",names.c_entry_class_name);
	printfnl("");
	printfnl("    ASSERT(callback);");
	printfnl("    ");
	printfnl("    for(i = 0; i < self->capacity; i++)");
	printfnl("    {");
	printfnl("        p = self->data[i];");
	printfnl("        if(p == NULL)continue;");
	printfnl("");
	printfnl("        pre = p;");
	printfnl("        p = p->next;");
	printfnl("        while(p)");
	printfnl("        {            ");
	printfnl("            next = p->next;");
	printfnl("            closure_set_param_pointer(callback,0,%s_get(p));",names.entry_class_name);
	printfnl("            _contine = closure_run(callback);");
	printfnl("            if(closure_get_param_pointer(callback,0) == NULL)");
	printfnl("            {");
	printfnl("                pre->next = next;");
	printfnl("                p = next;");
	printfnl("                self->size--;");
	printfnl("            }");
	printfnl("            else");
	printfnl("            {");
	printfnl("                pre = p;");
	printfnl("                p = next;");
	printfnl("            }");
	printfnl("");
	printfnl("            if(!_contine)");
	printfnl("                goto end;");
	printfnl("        }");
	printfnl("");
	printfnl("        p = self->data[i];");
	printfnl("        next = p->next;");
	printfnl("        closure_set_param_pointer(callback,0,%s_get(p));",names.entry_class_name);
	printfnl("        _contine = closure_run(callback);");
	printfnl("        if(closure_get_param_pointer(callback,0) == NULL)");
	printfnl("        {");
	printfnl("            self->data[i] = next;");
	printfnl("            self->size--;");
	printfnl("        }");
	printfnl("        if(!_contine)");
	printfnl("            goto end;");
	printfnl("    }");
	printfnl("");
	printfnl("end:");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("");
	printfnl("%s* %s_remove(%s *self,%s *key)",names.c_entry_class_name,names.class_name_lower,names.c_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    int code;");
	printfnl("    %s *pre,*p;",names.c_entry_class_name);
	printfnl("");
	printfnl("    ASSERT(key);");
	printfnl("    code = %s_hash_code(self,key);",names.class_name_lower);
	printfnl("    if(code < 0 || code >= self->capacity)");
	printfnl("        return NULL;");
	printfnl("    p = self->data[code];");
	printfnl("    if(p == NULL) return NULL;");
	printfnl("");
	printfnl("    if(%s_equals(self,%s_get(p),key))",names.class_name_lower,names.entry_class_name);
	printfnl("    {");
	printfnl("        self->data[code] = p->next;");
	printfnl("        self->size --;");
	printfnl("        return p;");
	printfnl("    }");
	printfnl("    else");
	printfnl("    {");
	printfnl("        while(p)");
	printfnl("        {");
	printfnl("            pre = p;");
	printfnl("            p = p->next;");
	printfnl("            if(p && %s_equals(self,%s_get(p),key))",names.class_name_lower,names.entry_class_name);
	printfnl("            {");
	printfnl("                pre->next = p->next;");
	printfnl("                self->size --;");
	printfnl("                return p;");
	printfnl("            }");
	printfnl("        }");
	printfnl("    }");
	printfnl("");
	printfnl("    return NULL;");
	printfnl("}");
	printfnl("");
	printfnl("status_t %s_del(%s *self,%s *key)",names.class_name_lower,names.c_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    %s *p = %s_remove(self,key);",names.c_entry_class_name,names.class_name_lower);
	printfnl("    if(p != NULL)");
	printfnl("    {");
	printfnl("        return %s_del_entry(self,p);",names.class_name_lower);
	printfnl("    }");
	printfnl("    return ERROR;");
	printfnl("}");
	printfnl("");
	printfnl("int %s_get_size(%s *self)",names.class_name_lower,names.c_class_name);
	printfnl("{");
	printfnl("    return self->size;");
	printfnl("}");
	printfnl("");
	printfnl("bool_t %s_is_empty(%s *self)",names.class_name_lower,names.c_class_name);
	printfnl("{");
	printfnl("    return %s_get_size(self) <= 0;",names.class_name_lower);
	printfnl("}");
	printfnl("");
	
	printfnl("status_t %s_print(%s *self,struct log_buffer *buf)",names.class_name_lower,names.c_class_name);
	printfnl("{");
	printfnl("    int i;");
	printfnl("    int collision = 0;");
	printfnl("    int maxLength = 0;");
	printfnl("");
	printfnl("    for(i = 0; i < self->capacity; i++)");
	printfnl("    {");
	printfnl("        %s *p = self->data[i];",names.c_entry_class_name);
	printfnl("        if(p != NULL)");
	printfnl("        {");
	printfnl("            int len = 0;");
	printfnl("            collision--;");
	printfnl("            while(p)");
	printfnl("            {                ");
	printfnl("                p = p->next;");
	printfnl("                len ++;");
	printfnl("                collision++;");
	printfnl("            }");
	printfnl("            if(len > maxLength)");
	printfnl("                maxLength = len;");
	printfnl("        }");
	printfnl("    }");
	printfnl("");
	printfnl("    log_buffer_log(buf,\"capacity is %%d\", self->capacity);");
	printfnl("    log_buffer_log(buf,\"total size is %%d\",self->size);");
	printfnl("    log_buffer_log(buf,\"maximum linked list length is %%d\",maxLength);");
	printfnl("    log_buffer_log(buf,\"total collison is %%d\",collision);");
	printfnl("    return OK;");
	printfnl("}");

	
	printfnl("");
	printfnl("status_t %s_del_entry(%s *self,%s *entry)",names.class_name_lower,names.c_class_name,names.c_entry_class_name);
	printfnl("{");
	printfnl("    %s_destroy(entry);",names.entry_class_name);
	printfnl("    X_FREE(entry);");
	printfnl("    return OK;");
	printfnl("}");
	printfnl("/*************************************************************************/");
	printfnl("/*************************************************************************/");
	printfnl("int %s_hash_code(%s *self,%s *node)",names.class_name_lower,names.c_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    ASSERT(node);");
	printfnl("    ASSERT(0);");
	printfnl("    return 0;");
	printfnl("}");
	printfnl("");
	printfnl("bool_t %s_equals(%s *self,%s *node1, %s *node2)",names.class_name_lower,names.c_class_name,names.c_node_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    ASSERT(node1 && node2);");
	printfnl("    return %s_comp(node1,node2) == 0;",names.node_class_name_lower);
	printfnl("}");
	printfnl("");
	printfnl("%s* %s_clone_node(%s *self,%s *node)",names.c_node_class_name,names.class_name_lower,names.c_class_name,names.c_node_class_name);
	printfnl("{");
	printfnl("    %s *ptr;",names.c_node_class_name);
	printfnl("    X_MALLOC(ptr,%s,1);",names.c_node_class_name);
	printfnl("    %s_init(ptr);",names.node_class_name_lower);
	printfnl("    %s_copy(ptr,node);",names.node_class_name_lower);
	printfnl("    return ptr;");
	printfnl("}");
	printfnl("");
end